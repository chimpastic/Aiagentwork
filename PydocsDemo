import os
import sys
import argparse  # We'll use this to accept a filename from the user
from docx import Document
from docx.text.paragraph import Paragraph
from docx.table import Table
from docx.oxml.ns import qn
from docx.shared import Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH

def create_sample_docx(filename="sample_document.docx"):
    """
    Creates a sample .docx file with mixed paragraphs and tables for testing.
    """
    print(f"Creating sample file: {filename}...")
    
    doc = Document()
    doc.add_heading("Document with Mixed Content", level=0)
    doc.add_paragraph(
        "This is the first paragraph. It appears before any tables. "
        "We want to extract this text first."
    )
    doc.add_heading("First Table", level=2)
    table1 = doc.add_table(rows=2, cols=2)
    table1.style = 'Table Grid'
    table1.cell(0, 0).text = "Header 1"
    table1.cell(0, 1).text = "Header 2"
    table1.cell(1, 0).text = "Cell (1,0)"
    table1.cell(1, 1).text = "Cell (1,1)"
    doc.add_paragraph(
        "This second paragraph is located between the two tables. "
        "Its sequence (after the first table and before the second) is important."
    )
    doc.add_heading("Second Table", level=2)
    table2 = doc.add_table(rows=3, cols=3)
    table2.style = 'Table Grid'
    for i in range(3):
        for j in range(3):
            table2.cell(i, j).text = f"Row {i+1}, Col {j+1}"
    doc.add_paragraph("This is the final paragraph, appearing after all other content.")
    doc.save(filename)
    print("Sample file created successfully.")


def extract_docx_content(filepath):
    """
    Extracts paragraphs, headings, and tables from a .docx file in sequential order.
    """
    
    doc = Document(filepath)
    full_content = []

    for element in doc.element.body:
        if element.tag == qn('w:p'):
            paragraph = Paragraph(element, doc)
            text = paragraph.text.strip()
            is_heading = paragraph.style.name.startswith('Heading')
            
            if text:
                if is_heading:
                    full_content.append(("heading", text, paragraph.style.name))
                else:
                    full_content.append(("paragraph", text))
        
        elif element.tag == qn('w:tbl'):
            table = Table(element, doc)
            table_data = []
            for row in table.rows:
                row_data = []
                for cell in row.cells:
                    row_data.append(cell.text)
                table_data.append(row_data)
            full_content.append(("table", table_data))
            
    return full_content


def main():
    """
    Main function to run the script.
    """
    
    # --- Set up the command-line argument parser ---
    parser = argparse.ArgumentParser(
        description="Extract sequential content (paragraphs, headings, tables) from a .docx file."
    )
    
    # Add a positional argument for the filename.
    # nargs='?' makes it optional, so we can run with --create-sample alone
    parser.add_argument(
        "filename", 
        nargs='?', 
        help="The path to the .docx file you want to read."
    )
    
    # Add an optional flag to create our sample file
    parser.add_argument(
        "--create-sample", 
        action="store_true", 
        help="Create a 'sample_document.docx' file for testing."
    )
    
    args = parser.parse_args()
    
    # --- Logic for what to do ---
    
    # 1. If they just want to create the sample file
    if args.create_sample:
        create_sample_docx("sample_document.docx")
        print("\nSample file 'sample_document.docx' created.")
        print("You can now run this command to read it:")
        print("  python docx_extractor.py sample_document.docx")
        sys.exit(0)
        
    # 2. If they didn't provide a filename or --create-sample
    if not args.filename:
        parser.print_help()
        print("\nError: You must provide a filename to read or use --create-sample.")
        sys.exit(1)
        
    filepath = args.filename

    # 3. Validation checks for the provided file
    if not os.path.exists(filepath):
        print(f"Error: File not found at '{filepath}'")
        sys.exit(1)
        
    if not filepath.lower().endswith('.docx'):
        print(f"Error: The file must be a .docx file. Provided: '{filepath}'")
        sys.exit(1)

    # 4. If all checks pass, try to process the user's file
    try:
        print(f"--- Extracting content from: {filepath} --- \n")
        
        content = extract_docx_content(filepath)
        
        if not content:
            print("No text content (paragraphs, headings, or tables) was found in this document.")
            print("NOTE: This script does not extract text from headers, footers, or text boxes.")
            return

        # Loop through and print the content
        for item in content:
            item_type = item[0]
            
            if item_type == "paragraph":
                print(f"[PARAGRAPH]")
                print(item[1])
            
            elif item_type == "heading":
                print(f"[{item[2].upper()}]") # e.g., [HEADING 2]
                print(item[1])

            elif item_type == "table":
                print(f"[TABLE]")
                table_data = item[1]
                for row in table_data:
                    print("  | " + " | ".join(cell.ljust(15) for cell in row) + " |")
            
            print("...\n")

    except Exception as e:
        print(f"An error occurred while processing '{filepath}': {e}")
        print("The file might be corrupted, password-protected, or not a valid .docx file.")

if __name__ == "__main__":
    main()


